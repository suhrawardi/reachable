.type List = [
    head: symbol,
    tail: List
]
.type X = symbol
.type Y = symbol

.decl Popularity(x:X, i:number)
.decl Edge(x:X, xType:symbol, y:Y, yType:symbol)
.decl Path(x:X, y:Y, p:List, i:number)
.decl ShortestPath(x:X, y:Y, p:List, i:number)
.decl ShortestPathLen(x:X, y:Y, i:number)
// .decl BufferOut(x:X, xT:symbol, y:Y, yT:symbol, i:number, s:symbol, p:List)
// .decl Out(x:X, xT:symbol, y:Y, yT:symbol, i:number, s:symbol)
.decl Out(x:X, y:Y, p:List, i:number)

.input Edge(IO=file, filename="edges.csv", delimiter=",")
.output Out(IO=file, filename="out.csv", delimiter=",")
.output Popularity(IO=file, filename="popularity.csv", delimiter=",")

Popularity(y, count : { Edge(_, _, y, _) }) :- Edge(_, _, y, _).

Path(x, y, [y, [x, nil]], 1) :- Edge(x, "TA", y, _).
Path(x, z, p, (i + 1)) :- Path(x, y, p2, i), Edge(y, _, z, _), p = [z, p2], i < 15.

ShortestPathLen(x, y, min i: { Path(x, y, _, i) }) :- Path(x, y, _, _).

ShortestPath(x, y, p, i) :- Path(x, y, p, i).

Out(x, y, p, i) :- ShortestPath(x, y, p, i).

// PathOut(x, xt, y, yt, i) :- Path(x, y), Reachable(x, xt, y, yt, i, _), i3 = min i2 : { Reachable(x, _, y, _, i2, _) }, i = i3.

// BufferOut(x, xt, y, yt, i, s, p2) :- Reachable(x, xt, y, yt, i, p), [s, p2] = p.
// BufferOut(x, xt, y, yt, i, cat(b, cat(" -> ", a)), p2) :- BufferOut(x, xt, y, yt, i, a, p), p != nil, [b, p2] = p.

// Out(x, xt, y, "", i, s) :- BufferOut(x, xt, y, "0", i, s, _), i3 = min i2 : { BufferOut(x, _, y, _, i2, _, _) }, i = i3.
// Out(x, xt, y, yt, i, s) :- BufferOut(x, xt, y, yt, i, s, _), i3 = min i2 : { BufferOut(x, _, y, _, i2, _, _) }, i = i3, ord(yt) != ord("0").

